"""
SD Card Interface Test Suite for Raspberry Pi Pico 2 W with MicroPython

MIT License

Copyright (c) 2025 Ojas Jha

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================================================================================

=== OVERVIEW ===
This comprehensive test program demonstrates how to interface with SD cards using
the Raspberry Pi Pico 2 W and MicroPython. It covers the complete workflow from
hardware initialization to file system operations, making it perfect for learning
embedded data logging and storage concepts.

=== WHAT THIS TEST DEMONSTRATES ===
1. SPI Interface Configuration: Setting up hardware SPI communication
2. SD Card Initialization: Proper card detection and setup sequence
3. File System Mounting: Creating a virtual file system on the SD card
4. Data Logging: Writing timestamped data entries (simulating sensor data)
5. Data Retrieval: Reading back stored data for verification
6. Error Handling: Robust error detection and user feedback

=== RASPBERRY PI PICO 2 W FEATURES USED ===
- RP2040 Hardware SPI Controller (SPI0)
- GPIO pins configured for SPI communication
- MicroPython's VFS (Virtual File System) integration
- Built-in time functions for timestamping

=== HARDWARE CONNECTIONS ===
Connect your SD card module to the Raspberry Pi Pico as follows:

SD Card Module    →    Raspberry Pi Pico 2 W
-----------------     ---------------------
CS (Chip Select) →    GPIO 13 (Pin 17)
SCK (Serial Clock) →  GPIO 10 (Pin 14) - SPI1 SCK
MOSI (Master Out) →   GPIO 11 (Pin 15) - SPI1 TX
MISO (Master In)  →   GPIO 12 (Pin 16) - SPI1 RX
VCC               →   3.3V (Pin 36) - IMPORTANT: Not 5V!
GND               →   GND (Pin 38)

=== WIRING DIAGRAM EXPLANATION ===
- CS: Active-low chip select signal (Pico controls when SD card listens)
- SCK: Clock signal generated by Pico (synchronizes data transfer)
- MOSI: Data from Pico to SD card (commands and data to write)
- MISO: Data from SD card to Pico (responses and data to read)
- VCC: Power supply - SD cards typically run at 3.3V (never use 5V!)
- GND: Common ground reference for all signals

=== SD CARD COMPATIBILITY ===
Supported SD card types:
- SDSC (Standard Capacity): Up to 2GB, FAT16 filesystem
- SDHC (High Capacity): 2GB to 32GB, FAT32 filesystem
- SDXC (Extended Capacity): 32GB to 2TB, exFAT filesystem

Recommended: Use FAT32 formatted cards for best compatibility with MicroPython

=== DATA LOGGING CONCEPTS ===
This test simulates a typical embedded data logging scenario:
- Periodic data collection (10 iterations with timestamps)
- Structured data format (iteration number + timestamp + message)
- File system operations (create, write, read, verify)
- Error handling and status reporting

=== EDUCATIONAL REFERENCES ===
- https://how2electronics.com/micro-sd-card-module-with-raspberry-pi-pico-micropython/
- https://www.instructables.com/Raspberry-Pi-Pico-Micro-SD-Card-Interface/
- https://how2electronics.com/data-logger-with-sd-card-raspberry-pi-pico-micropython/
- https://docs.micropython.org/en/latest/rp2/quickref.html (MicroPython Pico Reference)
- https://www.raspberrypi.com/documentation/microcontrollers/pico-series.html (Pico Hardware)

"""

# =============================================================================
# IMPORTS AND DEPENDENCIES
# =============================================================================

# MicroPython hardware interface modules
import machine  # Hardware control (SPI, GPIO pins) - core MicroPython module
import time     # Time functions for delays and timestamps - standard Python module
import utime    # MicroPython time module for sleep functions

# Custom SD card driver and file system modules
import sdcard_handler   # Our custom SD card driver (from sdcard_handler.py)
import uos      # MicroPython OS interface for filesystem operations

# =============================================================================
# HARDWARE INITIALIZATION FUNCTIONS
# =============================================================================

def initialize_sd_card_interface():
    """
    Initialize SPI interface and SD card for Raspberry Pi Pico 2 W.

    This function sets up the complete hardware interface chain:
    1. Configure GPIO pins for SPI communication
    2. Initialize SPI controller with appropriate settings
    3. Create and initialize SD card driver instance

    === SPI CONFIGURATION DETAILS ===
    - SPI Controller: SPI1 (one of two available on RP2040)
    - Baudrate: 1MHz (safe speed for reliable initialization)
    - Polarity: 0 (clock idle state is LOW)
    - Phase: 0 (data sampled on first/rising clock edge)
    - Bit Order: MSB first (most significant bit transmitted first)
    - Data Width: 8 bits per transfer (standard for SD cards)

    === GPIO PIN ASSIGNMENTS ===
    These pins are chosen to match SPI1 hardware controller on RP2040:
    - GPIO 13: CS (Chip Select) - any available GPIO can be used
    - GPIO 10: SCK (Serial Clock) - must be SPI1 SCK pin
    - GPIO 11: MOSI (Master Out Slave In) - must be SPI1 TX pin
    - GPIO 12: MISO (Master In Slave Out) - must be SPI1 RX pin

    Returns:
        tuple: (spi_interface, chip_select_pin, sd_card_driver)
            spi_interface (machine.SPI): Configured SPI controller instance
            chip_select_pin (machine.Pin): GPIO pin for chip select control
            sd_card_driver (sdcard.SDCard): Initialized SD card driver

    Raises:
        OSError: If SD card initialization fails (card not present, wiring issues, etc.)

    Example:
        spi, cs, sd = initialize_sd_card_interface()
        # Now sd can be used for filesystem operations
    """
    print("Initializing SD card interface...")

    # === STEP 1: CONFIGURE CHIP SELECT PIN ===
    # CS pin must be configured as output and start HIGH (deselected)
    # SD cards use active-low chip select (LOW = selected, HIGH = deselected)
    chip_select_pin = machine.Pin(13, machine.Pin.OUT)

    # === STEP 2: INITIALIZE SPI CONTROLLER ===
    # Configure SPI1 controller with SD card compatible settings
    spi_interface = machine.SPI(
        1,                              # SPI controller number (1 = SPI1)
        baudrate=1000000,               # 1 MHz - safe speed for all SD cards
        polarity=0,                     # Clock idle state is LOW (CPOL=0)
        phase=0,                        # Sample on first clock edge (CPHA=0)
        bits=8,                         # 8-bit data transfers (SD card standard)
        firstbit=machine.SPI.MSB,       # Most significant bit first (SD standard)
        sck=machine.Pin(10),            # Serial clock - must use SPI1 SCK pin
        mosi=machine.Pin(11),           # Master out, slave in - SPI1 TX pin
        miso=machine.Pin(12)            # Master in, slave out - SPI1 RX pin
    )

    # === STEP 3: INITIALIZE SD CARD DRIVER ===
    # Create SD card driver instance - this will perform complete card initialization
    # The driver will automatically detect card type and configure addressing mode
    sd_card_driver = sdcard_handler.SDCard(spi_interface, chip_select_pin)
    print("SD card initialized successfully!")

    return spi_interface, chip_select_pin, sd_card_driver

# =============================================================================
# FILESYSTEM OPERATIONS
# =============================================================================

def mount_sd_card_filesystem(sd_card_driver, mount_point="/sd"):
    """
    Mount the SD card as a FAT filesystem in MicroPython's virtual filesystem.

    This function creates a bridge between the low-level SD card driver and
    MicroPython's high-level file system interface. Once mounted, you can use
    standard Python file operations (open, read, write) on the SD card.

    === VIRTUAL FILE SYSTEM (VFS) EXPLAINED ===
    MicroPython uses a Virtual File System that allows multiple storage devices
    to be mounted at different paths:
    - Internal flash: Usually mounted at "/"
    - SD card: Typically mounted at "/sd"
    - Other devices: Can be mounted at custom paths like "/usb", "/ram", etc.

    === FAT FILESYSTEM SUPPORT ===
    VfsFat supports:
    - FAT16: Used on smaller SD cards (≤2GB)
    - FAT32: Most common format for SD cards (2GB-32GB)
    - Long filenames (up to 255 characters)
    - Standard file operations (create, read, write, delete, rename)

    Args:
        sd_card_driver (sdcard_handler.SDCard): Initialized SD card driver instance
        mount_point (str): Directory path where SD card will be accessible
            Default: "/sd" - creates /sd directory for SD card access

    Returns:
        uos.VfsFat: Virtual filesystem object representing the mounted SD card

    Raises:
        OSError: If mounting fails (filesystem corruption, incompatible format, etc.)

    Example:
        vfs = mount_sd_card_filesystem(sd_driver, "/sd")
        # Now you can use: open("/sd/file.txt", "w")
    """
    print(f"Mounting SD card at {mount_point}...")

    # === STEP 1: CREATE FAT FILESYSTEM INTERFACE ===
    # VfsFat wraps our block device (SD card) with FAT filesystem logic
    # This handles file allocation table, directory entries, cluster management
    virtual_filesystem = uos.VfsFat(sd_card_driver)

    # === STEP 2: MOUNT THE FILESYSTEM ===
    # Register the filesystem at the specified mount point
    # After this, file paths starting with mount_point will access the SD card
    uos.mount(virtual_filesystem, mount_point)
    print(f"SD card mounted successfully at {mount_point}")

    return virtual_filesystem

# =============================================================================
# DATA LOGGING AND FILE TESTING FUNCTIONS
# =============================================================================

def test_file_operations(test_file_path="/sd/sdcard-test.txt"):
    """
    Test comprehensive file write and read operations on the SD card.

    This function demonstrates a complete data logging workflow by writing
    timestamped test messages multiple times, then reading them back for
    verification. This simulates real-world embedded data logging scenarios
    like sensor data collection, system monitoring, or event logging.

    === DATA LOGGING SIMULATION ===
    The test performs 10 iterations of data writing, each containing:
    - Iteration header with timestamp
    - Multiple data messages with individual timestamps
    - Structured formatting for easy parsing
    - Progress feedback during writing

    === TIMESTAMP EXPLANATION ===
    MicroPython's time.time() returns seconds since epoch (January 1, 1970)
    This is a standard Unix timestamp format that can be converted to
    human-readable dates using time conversion functions.

    === FILE FORMAT EXAMPLE ===
    === Iteration  1 - Time: 1234567890s ===
    [ 1.1] Hello, SD World! - Time: 1234567890s
    [ 1.2] This is a test from Raspberry Pi Pico 2 W - Time: 1234567890s
    [ 1.3] SD card interface working correctly! - Time: 1234567890s

    Writes test messages 10 times with timestamps to demonstrate
    data logging functionality.

    Args:
        test_file_path: Path to the test file on the SD card
    """
    print(f"Testing file operations with {test_file_path}...")

    # Base test messages to write to the file
    base_messages = [
        "Hello, SD World!",
        "This is a test from Raspberry Pi Pico 2 W",
        "SD card interface working correctly!"
    ]

    # Write test data to file with timestamps (10 iterations)
    print("Writing test data with timestamps to SD card (10 iterations)...")

    # Initialize LED for progress indication
    led: machine.Pin = machine.Pin("LED", machine.Pin.OUT)

    try:
        with open(test_file_path, "w") as output_file:
            for iteration in range(1, 11):  # Write 10 times
                # Toggle LED to indicate iteration progress
                led.toggle()
                utime.sleep(1)    # Keep LED on for 1 s
                led.toggle()

                # Get current timestamp (seconds since epoch)
                current_time = time.time()

                # Convert to a more readable format
                # Note: MicroPython's time module is limited, so we use basic formatting
                timestamp_str = f"Time: {current_time:.0f}s"

                # Write header for this iteration
                header = f"=== Iteration {iteration:2d} - {timestamp_str} ===\r\n"
                output_file.write(header)
                print(f"  Writing iteration {iteration}...")

                # Write each base message with iteration info
                for msg_index, message in enumerate(base_messages, 1):
                    timestamped_message = f"[{iteration:2d}.{msg_index}] {message} - {timestamp_str}\r\n"
                    output_file.write(timestamped_message)

                # Add separator between iterations
                output_file.write("\r\n")

                # Small delay between iterations to show time progression
                time.sleep_ms(100)  # 100ms delay

        print(f"File write completed successfully! Written {10} iterations with timestamps.")

    except Exception as write_error:
        print(f"Error writing to file: {write_error}")
        return False

    # Read test data back from file
    print("Reading test data from SD card...")
    try:
        with open(test_file_path, "r") as input_file:
            file_contents = input_file.read()
            print("File read completed successfully!")

            # Display file statistics
            line_count = file_contents.count('\n')
            file_size = len(file_contents.encode('utf-8'))
            print(f"File statistics: {line_count} lines, {file_size} bytes")

            print("File contents:")
            print("-" * 50)
            print(file_contents)
            print("-" * 50)

    except Exception as read_error:
        print(f"Error reading from file: {read_error}")
        return False

    return True

# =============================================================================
# MAIN TEST EXECUTION
# =============================================================================

def main():
    """
    Main test execution function - orchestrates the complete SD card test sequence.

    This function coordinates all the test components in the correct order:
    1. Hardware initialization and SD card detection
    2. Filesystem mounting and preparation
    3. Data logging simulation with file operations
    4. Results verification and reporting
    5. Error handling and troubleshooting guidance

    === TEST SEQUENCE EXPLAINED ===
    The test follows a logical progression that mirrors real embedded applications:
    - Initialize hardware interfaces (SPI, GPIO)
    - Detect and configure storage device (SD card)
    - Mount filesystem for high-level operations
    - Perform application-specific data operations
    - Verify data integrity and report status

    === ERROR HANDLING STRATEGY ===
    The function uses comprehensive try-catch blocks to handle common issues:
    - Hardware connection problems (wiring, loose connections)
    - SD card issues (not inserted, corrupted, wrong format)
    - Filesystem problems (mounting failures, permission issues)
    - File operation errors (disk full, read-only card)

    Returns:
        None: Prints test results and status messages to console

    Example Output:
        ==================================================
        SD Card Test for Raspberry Pi Pico 2 W
        ==================================================
        Initializing SD card interface...
        SD card initialized successfully!
        Mounting SD card at /sd...
        SD card mounted successfully at /sd
        Testing file operations...
        [OK]All tests passed successfully!
    """
    print("=" * 50)
    print("SD Card Test for Raspberry Pi Pico 2 W")
    print("=" * 50)

    try:
        # Initialize SD card interface
        spi_interface, chip_select_pin, sd_card_driver = initialize_sd_card_interface()

        # Mount SD card filesystem
        virtual_filesystem = mount_sd_card_filesystem(sd_card_driver)

        # genereate and pass the filename to the test_file_operations function
        # Create filename with timestamp
        current_time = time.time()
        log_file_path = f"/sd/data_log_{int(current_time)}.txt"

        # Test file operations
        if test_file_operations(log_file_path):
            print("\n[OK]All tests passed successfully!")
        else:
            print("\n[✗]  Some tests failed!")

    except Exception as main_error:
        print(f"\n[✗]  Test failed with error: {main_error}")
        print("Please check:")
        print("- SD card is properly inserted")
        print("- Wiring connections are correct")
        print("- SD card is formatted (FAT32 recommended)")

# Run the test
if __name__ == "__main__":
    main()