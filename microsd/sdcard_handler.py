"""
SD Card Driver for MicroPython - Comprehensive Implementation for Raspberry Pi Pico

MIT License

Copyright (c) 2025 Ojas Jha

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================================================================================

This module provides a complete SD card interface using SPI (Serial Peripheral Interface)
communication protocol. It enables the Raspberry Pi Pico to read from and write to SD cards,
allowing them to be mounted as a filesystem for data storage and logging applications.

=== WHAT IS SPI COMMUNICATION? ===
SPI is a synchronous serial communication protocol that uses four wires:
- MOSI (Master Out Slave In): Data from Pico to SD card
- MISO (Master In Slave Out): Data from SD card to Pico
- SCK (Serial Clock): Clock signal generated by Pico
- CS (Chip Select): Signal to select/deselect the SD card

=== SD CARD COMMUNICATION PROTOCOL ===
SD cards communicate using commands (CMD0, CMD8, etc.) that follow a specific format:
1. 6-byte command packet sent to card
2. Card responds with R1 response (1 byte) or longer responses
3. Data blocks (512 bytes) are transferred with start tokens and CRC

=== RASPBERRY PI PICO ARCHITECTURE NOTES ===
The RP2040 microcontroller on the Pico has:
- Two SPI controllers (SPI0 and SPI1)
- Programmable I/O (PIO) for custom protocols
- 30 GPIO pins that can be assigned to SPI functions
- Hardware SPI is faster and more reliable than bit-banging

Original Implementation: https://github.com/micropython/micropython/tree/master/drivers/sdcard
Raw Source: https://raw.githubusercontent.com/micropython/micropython/master/drivers/sdcard/sdcard.py

=== FILESYSTEM INTEGRATION ===
This driver implements the block device interface required by MicroPython's VFS (Virtual File System):
- readblocks(): Read 512-byte sectors from SD card
- writeblocks(): Write 512-byte sectors to SD card
- ioctl(): Get device information (sector count, block size)

=== HARDWARE CONNECTIONS FOR RASPBERRY PI PICO ===
Standard SPI0 connections:
- CS (Chip Select): GPIO 1 (or any available GPIO)
- SCK (Serial Clock): GPIO 2 (SPI0 SCK)
- MOSI (Master Out Slave In): GPIO 3 (SPI0 TX)
- MISO (Master In Slave Out): GPIO 4 (SPI0 RX)
- VCC: 3.3V (important: not 5V!)
- GND: Ground

Example usage on Raspberry Pi Pico:
    import machine, sdcard_handler, os

    # Initialize SPI interface on SPI0 with specific pins
    spi_interface = machine.SPI(0,
                               sck=machine.Pin(2),    # Serial clock
                               mosi=machine.Pin(3),   # Master out, slave in
                               miso=machine.Pin(4))   # Master in, slave out

    # Chip select pin (active low)
    chip_select_pin = machine.Pin(1)

    # Create SD card driver instance
    sd_card = sdcard_handler.SDCard(spi_interface, chip_select_pin)

    # Mount as filesystem and use
    os.mount(sd_card, '/sd')
    os.listdir('/sd')

Example usage on ESP8266:
    import machine, sdcard_handler, os
    sd_card = sdcard_handler.SDCard(machine.SPI(1), machine.Pin(15))
    os.mount(sd_card, '/sd')
    os.listdir('/')

=== SUPPORTED SD CARD TYPES ===
- SDSC (Standard Capacity): Up to 2GB, uses byte addressing
- SDHC (High Capacity): 2GB to 32GB, uses block addressing
- SDXC (Extended Capacity): 32GB to 2TB, uses block addressing

"""

# =============================================================================
# IMPORTS AND DEPENDENCIES
# =============================================================================

# MicroPython-specific imports
from micropython import const  # Compile-time constants for memory efficiency
import time                    # Time functions for delays and timestamps

# =============================================================================
# SD CARD PROTOCOL CONSTANTS
# =============================================================================

# === COMMUNICATION TIMING ===
# Maximum number of SPI clock cycles to wait for SD card responses
# SD cards can be slow to respond, especially during initialization
COMMAND_TIMEOUT_CYCLES = const(100)

# === R1 RESPONSE FLAGS ===
# R1 is the most common SD card response format (1 byte)
# Each bit indicates a specific card state or error condition
# Bit 0: Card is in idle state (expected during initialization)
R1_RESPONSE_IDLE_STATE = const(1 << 0)       # 0x01 - Card in idle state
# R1_RESPONSE_ERASE_RESET = const(1 << 1)    # 0x02 - Erase reset flag
R1_RESPONSE_ILLEGAL_COMMAND = const(1 << 2)  # 0x04 - Illegal command received
# R1_RESPONSE_CRC_ERROR = const(1 << 3)      # 0x08 - CRC check failed
# R1_RESPONSE_ERASE_SEQUENCE_ERROR = const(1 << 4)  # 0x10 - Erase sequence error
# R1_RESPONSE_ADDRESS_ERROR = const(1 << 5)   # 0x20 - Address error
# R1_RESPONSE_PARAMETER_ERROR = const(1 << 6) # 0x40 - Parameter error
# Bit 7 is always 0 in valid R1 responses

# === DATA TRANSFER TOKENS ===
# These special bytes indicate the start of data blocks or control commands
# They help synchronize data transfer between Pico and SD card
TOKEN_MULTI_BLOCK_WRITE = const(0xFC)    # Start token for multiple block write (CMD25)
TOKEN_STOP_TRANSMISSION = const(0xFD)    # Stop token to end multiple block operations
TOKEN_START_BLOCK = const(0xFE)          # Start token for single block read/write


# =============================================================================
# MAIN SD CARD DRIVER CLASS
# =============================================================================

class SDCard:
    """
    SD Card Driver for Raspberry Pi Pico using SPI Communication

    This class provides a complete interface to SD cards, implementing the SD card
    specification for SPI mode communication. It handles all the low-level protocol
    details and presents a simple block device interface that can be used with
    MicroPython's filesystem.

    === KEY CONCEPTS ===
    Block Device: SD cards are organized into 512-byte blocks (sectors)
    SPI Mode: SD cards can operate in SPI mode (slower) or SD mode (faster)
    Card Types: SDSC (â‰¤2GB), SDHC (2-32GB), SDXC (32GB-2TB)

    === INITIALIZATION SEQUENCE ===
    1. Power up SD card with slow SPI clock
    2. Send CMD0 to reset card to SPI mode
    3. Send CMD8 to check voltage compatibility and card version
    4. Initialize card (different process for v1.x vs v2.x cards)
    5. Read card capacity from CSD register
    6. Switch to high-speed SPI communication

    Attributes:
        spi_interface (machine.SPI): Hardware SPI controller instance
        chip_select_pin (machine.Pin): GPIO pin used for chip select (active low)
        total_sectors (int): Total number of 512-byte sectors on the card
        card_address_divisor (int): 1 for SDHC/SDXC (block addressing),
                                   512 for SDSC (byte addressing)
    """

    def __init__(self, spi_interface, chip_select_pin, spi_baudrate=1320000):
        """
        Initialize SD Card driver and perform complete card initialization sequence.

        This constructor performs the entire SD card initialization process:
        1. Sets up communication buffers
        2. Initializes SPI interface
        3. Resets and identifies the SD card
        4. Configures the card for data transfer
        5. Switches to high-speed communication

        Args:
            spi_interface (machine.SPI): SPI bus instance from machine.SPI()
                Example: machine.SPI(0, sck=Pin(2), mosi=Pin(3), miso=Pin(4))
            chip_select_pin (machine.Pin): GPIO pin for chip select (CS)
                Must be configured as output. Example: machine.Pin(1, machine.Pin.OUT)
            spi_baudrate (int, optional): Final SPI speed in Hz after initialization.
                Default: 1,320,000 Hz (1.32 MHz). Range: 100kHz - 25MHz

        Raises:
            OSError: If SD card is not detected, not responding, or initialization fails

        Example:
            import machine
            spi = machine.SPI(0, sck=machine.Pin(2), mosi=machine.Pin(3), miso=machine.Pin(4))
            cs = machine.Pin(1)
            sd = SDCard(spi, cs, 1000000)  # 1 MHz SPI speed
        """
        # Store hardware interface references
        # These will be used for all SD card communication
        self.spi_interface = spi_interface      # SPI controller (SPI0 or SPI1 on Pico)
        self.chip_select_pin = chip_select_pin  # CS pin (active low signal)

        # === COMMUNICATION BUFFERS ===
        # Pre-allocated buffers to avoid memory allocation during operations
        # This is important for embedded systems with limited RAM

        # Buffer for 6-byte SD card command packets
        # Format: [0x40|cmd, arg3, arg2, arg1, arg0, crc]
        self.command_buffer = bytearray(6)

        # Buffer for SPI dummy writes (512 bytes of 0xFF)
        # SPI requires data to be sent to receive data (full-duplex)
        # 0xFF is the SPI idle state and won't interfere with SD card data
        self.dummy_buffer = bytearray(512)

        # Single-byte buffer for reading response tokens and status bytes
        self.response_token_buffer = bytearray(1)

        # Initialize dummy buffer with SPI idle state (all bits high)
        # This represents the default state of SPI MOSI line when idle
        for i in range(512):
            self.dummy_buffer[i] = 0xFF

        # Create memory view for efficient buffer slicing without copying
        # Memory views allow zero-copy slicing of bytearrays
        self.dummy_buffer_view = memoryview(self.dummy_buffer)

        # === CARD INITIALIZATION ===
        # Perform complete SD card initialization sequence
        # This will populate self.total_sectors and self.card_address_divisor
        self.initialize_card(spi_baudrate)

    def initialize_spi_interface(self, baudrate):
        """
        Initialize SPI interface with platform-specific configuration.

        This method handles differences between MicroPython platforms (Pico vs PyBoard).
        The Raspberry Pi Pico uses a simpler SPI initialization compared to PyBoard.

        === SPI CONFIGURATION EXPLAINED ===
        - Baudrate: Clock frequency for SPI communication (Hz)
        - Phase 0: Data is sampled on the first (rising) edge of SCK
        - Polarity 0: SCK is low when idle (most common for SD cards)

        Args:
            baudrate (int): SPI communication speed in Hz
                - Initialization: 100kHz (slow but reliable)
                - Normal operation: 1-25MHz (faster data transfer)

        Platform Differences:
            - Raspberry Pi Pico: Uses simple init(baudrate=x, phase=0, polarity=0)
            - PyBoard: Requires MASTER mode parameter
        """
        try:
            # Try PyBoard-style initialization (has MASTER attribute)
            master = self.spi_interface.MASTER
        except AttributeError:
            # Raspberry Pi Pico and ESP8266 style initialization
            # These platforms don't have a MASTER attribute
            self.spi_interface.init(
                baudrate=baudrate,  # SPI clock frequency
                phase=0,           # Sample data on first clock edge
                polarity=0         # Clock idle state is low
            )
        else:
            # PyBoard style initialization requires MASTER mode
            self.spi_interface.init(
                master,                    # SPI master mode
                baudrate=baudrate,         # SPI clock frequency
                phase=0,                   # Sample data on first clock edge
                polarity=0                 # Clock idle state is low
            )

    def initialize_card(self, final_baudrate):
        """
        Perform complete SD card initialization sequence following SD specification.

        This is the main initialization method that follows the SD card specification
        for SPI mode initialization. The process must be done in a specific order
        with precise timing to ensure reliable communication.

        === INITIALIZATION SEQUENCE EXPLAINED ===
        1. Configure CS pin (must start high = deselected)
        2. Start with slow SPI clock (â‰¤400kHz per SD spec)
        3. Send 74+ clock cycles to wake up the card
        4. Send CMD0 to reset card and enter SPI mode
        5. Send CMD8 to check voltage compatibility and determine card version
        6. Initialize based on card version (v1.x or v2.x)
        7. Read card capacity information
        8. Switch to high-speed communication

        Args:
            final_baudrate (int): Final SPI speed in Hz to use after initialization
                Typically 1-25MHz for normal operation

        Raises:
            OSError: If card is not detected, doesn't respond, or initialization fails
        """
        # === STEP 1: CONFIGURE CHIP SELECT PIN ===
        # CS must be configured as output and start HIGH (deselected)
        # SD cards use active-low chip select (LOW = selected, HIGH = deselected)
        self.chip_select_pin.init(self.chip_select_pin.OUT, value=1)

        # === STEP 2: START WITH SLOW SPI CLOCK ===
        # SD specification requires â‰¤400kHz during initialization
        # This ensures reliable communication during card power-up
        self.initialize_spi_interface(100000)  # 100kHz - very safe speed

        # === STEP 3: WAKE UP THE SD CARD ===
        # Send at least 74 clock cycles with CS high to power up the card
        # This gives the card time to complete its internal power-up sequence
        # 16 bytes Ã— 8 bits = 128 clock cycles (exceeds minimum requirement)
        for i in range(16):
            self.spi_interface.write(b"\xff")

        # === STEP 4: RESET CARD TO SPI MODE (CMD0) ===
        # CMD0 resets the card and puts it into SPI mode
        # Some cards may not respond immediately, so we try up to 5 times
        # CRC is required for CMD0: 0x95 is the correct CRC for CMD0 with arg 0
        for attempt in range(5):
            if self.send_command(0, 0, 0x95) == R1_RESPONSE_IDLE_STATE:
                break
        else:
            raise OSError("No SD card detected or card not responding")

        # === STEP 5: CHECK CARD VERSION AND VOLTAGE (CMD8) ===
        # CMD8 was introduced in SD v2.0 specification
        # Argument 0x01AA: 0x01 = voltage range, 0xAA = check pattern
        # CRC 0x87 is correct for this CMD8 with argument 0x01AA
        response = self.send_command(8, 0x01AA, 0x87, 4)

        if response == R1_RESPONSE_IDLE_STATE:
            # Card supports CMD8 = SD v2.x card (SDHC/SDXC possible)
            self.initialize_card_v2()
        elif response == (R1_RESPONSE_IDLE_STATE | R1_RESPONSE_ILLEGAL_COMMAND):
            # Card doesn't support CMD8 = SD v1.x card (SDSC only)
            self.initialize_card_v1()
        else:
            raise OSError("Could not determine SD card version")

        # Read Card Specific Data (CSD) to get card capacity
        # CMD9: Read CSD register (R1 response + 16-byte data block)
        if self.send_command(9, 0, 0, 0, False) != 0:
            raise OSError("No response from SD card when reading CSD")

        card_specific_data = bytearray(16)
        self.read_data_block_into_buffer(card_specific_data)

        # Parse CSD to determine card capacity
        if card_specific_data[0] & 0xC0 == 0x40:  # CSD version 2.0 (SDHC/SDXC)
            self.total_sectors = ((card_specific_data[8] << 8 | card_specific_data[9]) + 1) * 1024
        elif card_specific_data[0] & 0xC0 == 0x00:  # CSD version 1.0 (SDSC, <=2GB)
            c_size = (card_specific_data[6] & 0b11) << 10 | card_specific_data[7] << 2 | card_specific_data[8] >> 6
            c_size_mult = (card_specific_data[9] & 0b11) << 1 | card_specific_data[10] >> 7
            read_block_length = card_specific_data[5] & 0b1111
            card_capacity = (c_size + 1) * (2 ** (c_size_mult + 2)) * (2 ** read_block_length)
            self.total_sectors = card_capacity // 512
        else:
            raise OSError("Unsupported SD card CSD format")

        # CMD16: Set block size to 512 bytes (standard sector size)
        if self.send_command(16, 512, 0) != 0:
            raise OSError("Cannot set 512-byte block size")

        # Switch to high-speed SPI communication now that card is initialized
        self.initialize_spi_interface(final_baudrate)

    def initialize_card_v1(self):
        """Initialize SD Card Version 1.x (SDSC - Standard Capacity)."""
        for attempt in range(COMMAND_TIMEOUT_CYCLES):
            self.send_command(55, 0, 0)  # CMD55: App command follows
            if self.send_command(41, 0, 0) == 0:  # ACMD41: Initialize card
                # SDSC card uses byte addressing for read/write/erase commands
                self.card_address_divisor = 512
                return
        raise OSError("Timeout waiting for SD Card v1.x initialization")

    def initialize_card_v2(self):
        """Initialize SD Card Version 2.x (SDHC/SDXC - High/Extended Capacity)."""
        for attempt in range(COMMAND_TIMEOUT_CYCLES):
            time.sleep_ms(50)
            self.send_command(58, 0, 0, 4)  # CMD58: Read OCR register
            self.send_command(55, 0, 0)     # CMD55: App command follows
            if self.send_command(41, 0x40000000, 0) == 0:  # ACMD41: Initialize with HCS bit
                # Read OCR register to determine card type
                self.send_command(58, 0, 0, -4)  # -4 means keep first byte only
                operation_conditions_register = self.response_token_buffer[0]

                if not operation_conditions_register & 0x40:
                    # SDSC card uses byte addressing for read/write/erase commands
                    self.card_address_divisor = 512
                else:
                    # SDHC/SDXC card uses block addressing for read/write/erase commands
                    self.card_address_divisor = 1
                return
        raise OSError("Timeout waiting for SD Card v2.x initialization")

    def send_command(self, command_index, argument, crc, additional_response_bytes=0, release_chip_select=True, skip_first_response=False):
        """Send a command to the SD card and wait for response.

        Args:
            command_index: SD card command number (0-63)
            argument: 32-bit command argument
            crc: 7-bit CRC for the command
            additional_response_bytes: Number of additional response bytes to read
            release_chip_select: Whether to release CS after command
            skip_first_response: Whether to skip the first response byte

        Returns:
            R1 response byte, or -1 if timeout
        """
        # Select the SD card
        self.chip_select_pin(0)

        # Build and send the 6-byte command packet
        command_buffer = self.command_buffer
        command_buffer[0] = 0x40 | command_index  # Start bit + transmission bit + command
        command_buffer[1] = argument >> 24        # Argument bits 31:24
        command_buffer[2] = argument >> 16        # Argument bits 23:16
        command_buffer[3] = argument >> 8         # Argument bits 15:8
        command_buffer[4] = argument              # Argument bits 7:0
        command_buffer[5] = crc                   # CRC + end bit
        self.spi_interface.write(command_buffer)

        # Skip first response byte if requested (for some multi-byte responses)
        if skip_first_response:
            self.spi_interface.readinto(self.response_token_buffer, 0xFF)

        # Wait for R1 response (MSB = 0 indicates valid response)
        for attempt in range(COMMAND_TIMEOUT_CYCLES):
            self.spi_interface.readinto(self.response_token_buffer, 0xFF)
            r1_response = self.response_token_buffer[0]

            if not (r1_response & 0x80):  # Valid response received
                # Handle additional response bytes
                if additional_response_bytes < 0:
                    # Negative value means keep first byte and discard the rest
                    self.spi_interface.readinto(self.response_token_buffer, 0xFF)
                    additional_response_bytes = -1 - additional_response_bytes

                # Read remaining response bytes
                for byte_index in range(additional_response_bytes):
                    self.spi_interface.write(b"\xff")

                # Release chip select if requested
                if release_chip_select:
                    self.chip_select_pin(1)
                    self.spi_interface.write(b"\xff")  # Send final clock

                return r1_response

        # Command timeout occurred
        self.chip_select_pin(1)
        self.spi_interface.write(b"\xff")
        return -1

    def read_data_block_into_buffer(self, buffer):
        """Read a data block from SD card into the provided buffer.

        Args:
            buffer: Buffer to store the read data

        Raises:
            OSError: If timeout waiting for data token
        """
        # Select the SD card
        self.chip_select_pin(0)

        # Wait for data start token (0xFE)
        for attempt in range(COMMAND_TIMEOUT_CYCLES):
            self.spi_interface.readinto(self.response_token_buffer, 0xFF)
            if self.response_token_buffer[0] == TOKEN_START_BLOCK:
                break
            time.sleep_ms(1)
        else:
            self.chip_select_pin(1)
            raise OSError("Timeout waiting for data block start token")

        # Read the actual data using write_readinto for efficiency
        dummy_data_view = self.dummy_buffer_view
        if len(buffer) != len(dummy_data_view):
            dummy_data_view = dummy_data_view[:len(buffer)]
        self.spi_interface.write_readinto(dummy_data_view, buffer)

        # Read and discard the 2-byte CRC
        self.spi_interface.write(b"\xff")
        self.spi_interface.write(b"\xff")

        # Deselect the SD card
        self.chip_select_pin(1)
        self.spi_interface.write(b"\xff")

    def write_data_block(self, start_token, data_buffer):
        """Write a data block to the SD card.

        Args:
            start_token: Token indicating start of data block
            data_buffer: Buffer containing data to write
        """
        # Select the SD card
        self.chip_select_pin(0)

        # Send: start token, data block, and dummy CRC
        self.spi_interface.read(1, start_token)
        self.spi_interface.write(data_buffer)
        self.spi_interface.write(b"\xff")  # Dummy CRC byte 1
        self.spi_interface.write(b"\xff")  # Dummy CRC byte 2

        # Check data response token (should be 0x05 for accepted)
        if (self.spi_interface.read(1, 0xFF)[0] & 0x1F) != 0x05:
            self.chip_select_pin(1)
            self.spi_interface.write(b"\xff")
            return

        # Wait for write operation to complete (card sends 0x00 while busy)
        while self.spi_interface.read(1, 0xFF)[0] == 0:
            pass

        # Deselect the SD card
        self.chip_select_pin(1)
        self.spi_interface.write(b"\xff")

    def send_control_token(self, control_token):
        """Send a control token to the SD card (e.g., stop transmission).

        Args:
            control_token: Control token to send
        """
        # Select the SD card
        self.chip_select_pin(0)

        # Send the control token
        self.spi_interface.read(1, control_token)
        self.spi_interface.write(b"\xff")

        # Wait for operation to complete (card sends 0x00 while busy)
        while self.spi_interface.read(1, 0xFF)[0] == 0x00:
            pass

        # Deselect the SD card
        self.chip_select_pin(1)
        self.spi_interface.write(b"\xff")

    def readblocks(self, starting_block_number, buffer):
        """Read one or more 512-byte blocks from the SD card.

        Args:
            starting_block_number: First block to read
            buffer: Buffer to store the read data (must be multiple of 512 bytes)

        Raises:
            AssertionError: If buffer size is not a multiple of 512 bytes
            OSError: If read operation fails
        """
        total_blocks = len(buffer) // 512
        assert total_blocks and not len(buffer) % 512, "Buffer length must be multiple of 512 bytes"

        if total_blocks == 1:
            # CMD17: Read single block
            block_address = starting_block_number * self.card_address_divisor
            if self.send_command(17, block_address, 0, release_chip_select=False) != 0:
                # Release the card and raise error
                self.chip_select_pin(1)
                raise OSError(5)  # EIO - Input/Output Error

            # Read the data block
            self.read_data_block_into_buffer(buffer)
        else:
            # CMD18: Read multiple blocks
            block_address = starting_block_number * self.card_address_divisor
            if self.send_command(18, block_address, 0, release_chip_select=False) != 0:
                # Release the card and raise error
                self.chip_select_pin(1)
                raise OSError(5)  # EIO - Input/Output Error

            # Read each block sequentially
            buffer_offset = 0
            buffer_view = memoryview(buffer)
            remaining_blocks = total_blocks

            while remaining_blocks:
                # Read current block into buffer slice
                current_block_buffer = buffer_view[buffer_offset:buffer_offset + 512]
                self.read_data_block_into_buffer(current_block_buffer)
                buffer_offset += 512
                remaining_blocks -= 1

            # CMD12: Stop transmission
            if self.send_command(12, 0, 0xFF, skip_first_response=True):
                raise OSError(5)  # EIO - Input/Output Error

    def writeblocks(self, starting_block_number, buffer):
        """Write one or more 512-byte blocks to the SD card.

        Args:
            starting_block_number: First block to write
            buffer: Buffer containing data to write (must be multiple of 512 bytes)

        Raises:
            AssertionError: If buffer size is not a multiple of 512 bytes
            OSError: If write operation fails
        """
        total_blocks, remainder = divmod(len(buffer), 512)
        assert total_blocks and not remainder, "Buffer length must be multiple of 512 bytes"

        if total_blocks == 1:
            # CMD24: Write single block
            block_address = starting_block_number * self.card_address_divisor
            if self.send_command(24, block_address, 0) != 0:
                raise OSError(5)  # EIO - Input/Output Error

            # Send the data block
            self.write_data_block(TOKEN_START_BLOCK, buffer)
        else:
            # CMD25: Write multiple blocks
            block_address = starting_block_number * self.card_address_divisor
            if self.send_command(25, block_address, 0) != 0:
                raise OSError(5)  # EIO - Input/Output Error

            # Write each block sequentially
            buffer_offset = 0
            buffer_view = memoryview(buffer)
            remaining_blocks = total_blocks

            while remaining_blocks:
                # Write current block from buffer slice
                current_block_buffer = buffer_view[buffer_offset:buffer_offset + 512]
                self.write_data_block(TOKEN_MULTI_BLOCK_WRITE, current_block_buffer)
                buffer_offset += 512
                remaining_blocks -= 1

            # Send stop transmission token
            self.send_control_token(TOKEN_STOP_TRANSMISSION)

    def ioctl(self, operation_code, argument):
        """Handle I/O control operations for the filesystem interface.

        Args:
            operation_code: Type of operation requested
            argument: Operation argument (unused)

        Returns:
            Requested information based on operation code
        """
        if operation_code == 4:  # Get total number of blocks
            return self.total_sectors
        if operation_code == 5:  # Get block size in bytes
            return 512
